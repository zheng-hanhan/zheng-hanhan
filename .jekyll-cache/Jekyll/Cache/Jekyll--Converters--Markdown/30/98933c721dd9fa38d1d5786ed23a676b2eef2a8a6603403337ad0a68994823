I";&<h2 id="环境简介">环境简介</h2>
<p>笔者的环境是搭在VMware Workstation虚拟出的Ubuntu 20.04操作系统实例上的，VMware Workstation
运行在搭载着Win10系统的笔记本上，笔记本硬件配置 CPU i7-8750H，内存16GB*2。</p>

<h2 id="llvm源码下载">LLVM源码下载</h2>
<p>LLVM的下载来源主要来自于这两个官方链接，一个是LLVM 稳定版本的下载<a href="#refer-anchor-1"><sup>1</sup></a>，即稳定的发布版
本。一个是LLVM在github上的下载<a href="#refer-anchor-2"><sup>2</sup></a>，这个可以理解成最新的不断更新的开发版本。本文采用后
者。将整个LLVM大项目下载下来（包含clang，llvm core，compiler-rt等等），整个过程比较耗时。</p>

<p>笔者在计算机上手动新建了一个目录，~/workspace/llvm。 然后在该目录下，执行了如下命令：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre>git clone https://github.com/llvm/llvm-project.git
</pre></td></tr></tbody></table></code></pre></div></div>
<p>如果只是运用clang和llvm相关工具，则可以单独下载clang和llvm代码，并将它们放置在同一个目录下即可（本文中的目录为llvm-project），
不需采用上述git clone的方式将所有代码都下载下来。</p>

<h2 id="llvm源码编译">LLVM源码编译</h2>
<p>代码下载完毕后，在~/workspace/llvm目录下，会出现一个目录llvm-project，进入该目录下，
可以看到如下文件陈列：</p>

<p><img src="../assets/img/2019-10-05-llvm_src_download_and_compiling/1.png" alt="LLVM Src Download and Compile" /></p>

<p>LLVM不支持直接在源码树中直接构建 （in-tree build is not supported），这也比较容易理解，
这样可以使得项目保持整洁，不至于混乱不堪，搅在一起。现在新建一个目录，用来存放待会编译
过程中产生的各种文件。我们在llvm-project这个文件夹下，新建一个目录，目录名可以随意取，
这里取名build，然后我们进入build目录，准备开始构建LLVM的编译。在正式开始之前，我们需
要简单了解一下CMake<a href="#refer-anchor-3"><sup>3</sup></a></p>

<blockquote>
  <p>CMake is a cross-platform build-generator tool. CMake does not build the project, it
generates the files needed by your build tool (GNU make, Visual Studio, etc.) for
building LLVM.</p>
</blockquote>

<p>CMake是跨平台的构建生成器，本身并不构建项目，而是生成各种makefile。真正构建项目的软
件（例如GNU make、Ninja等）将依据这些生成的make file文件来构建项目。</p>

<p>在build目录下，待会要执行如下的命令，从而产生必要的构建文件。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre>cmake -G &lt;generator&gt; [options] ../llvm
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">&lt;generator&gt;</code>：常见的有Ninja、Unix Makefiles 等。</p>

<p><code class="language-plaintext highlighter-rouge">[options]</code> ：这里介绍几个常见的</p>

<p>第一个就是 -DLLVM_ENABLE_PROJECTS=’…’ 选项， -D是define的意思，就是说，将
LLVM_ENABLE_PROJECTS整个变量定义为何值。LLVM_ENABLE_PROJECTS中列的值（如果有
多个值，以封号隔开），表示的是除了LLVM Core libraries外，还需要构建的子项目。本文需要
clang，所以本文-DLLVM_ENABLE_PROJECTS=”clang”。
另一个就是 -DCMAKE_BUILD_TYPE=type ，由于默认该项值是Debug，但是由于编译Debug时间太长，
而且对内存要求比较高，笔者这里将其修改成Release，即-DCMAKE_BUILD_TYPE=release
综上，笔者在build目录下，执行了如下命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre>cmake -G  Ninja  -DLLVM_ENABLE_PROJECTS="clang"  -DCMAKE_BUILD_TYPE=release ../llvm
</pre></td></tr></tbody></table></code></pre></div></div>

<p>在上述命令执行的过程中，cmake会检查当前的环境是否符合后续构建的要求，比如必要的软件是
否安装上、已经安装的软件，其版本是否符合要求等。比如，笔者遇到了Ninja版本不符合要求的
情况:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> --><td class="rouge-code"><pre>CMake Error: the detected version of Ninja (log: ninja version 0.1.3 initializing) is less than
the version of Ninja required by CMake (1.3).
</pre></td></tr></tbody></table></code></pre></div></div>
<p>也就是说，检测出Ninja的版本过低，这个时候可以去ninja的官网下载一个最新版本，然后替换掉
现有的低版本的Ninja。替换完毕之后，重新执行上面的cmake命令，仍然会提示上面ninja版本过
低的错误，这是由于，cmake基于上次执行的结果，直接给出的，它并没有刷新，所以，可以粗暴
的将build目录下的文件都删掉，然后重新执行一下上面的cmake命令，它就可以往下走了。</p>

<p>待cmake命令将构建文件生成完毕，此时在build目录下，直接执行</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre>ninja
</pre></td></tr></tbody></table></code></pre></div></div>
<p>就开始构建clang和llvm了。构建完毕之后，build目录结构如下：</p>

<p><img src="../assets/img/2019-10-05-llvm_src_download_and_compiling/2.png" alt="Detail of LLVM Build DIR" /></p>

<p>我们构建出的各个可执行文件在build/bin目录下，如下图：</p>

<p><img src="../assets/img/2019-10-05-llvm_src_download_and_compiling/3.png" alt="Detail of LLVM Build BIN DIR" /></p>

<p>将这个bin目录放置到系统的PATH变量中，就可以随时随地使用这些刚刚编译出炉的executable了。</p>

<p>笔者之前使用8G x 2的笔记本构建debug版本的llvm等，但是构建失败了，因为OOM了，于是笔者今天把内存换成了
16G x 2的了，分配给虚拟机的内存有25GB左右，然后使用下述命令再次构建。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre>cmake -G  Ninja  -DLLVM_ENABLE_PROJECTS="clang"  -DCMAKE_BUILD_TYPE=debug ../llvm
</pre></td></tr></tbody></table></code></pre></div></div>
<p>到最后快要构建完的时候，卡住了，卡了足足有10几个小时，整个ubuntu像freeze了一样，如下图：</p>

<p><img src="../assets/img/2019-10-05-llvm_src_download_and_compiling/llvm_build_debug_freeze.png" alt="LLVM Debug Build Freeze the System" /></p>

<p>使用htop命令查看了下内存占用，发现内存被吃光了，还吃光了swap分区。经过分析，猜测是ninja编译的时候启动了太多
的线程，以及默认的GNU的ld效率不高，于是我将ninja换成了make，同时linker换成gold，不再使用其默认的gnu linker，并控制开启线程的数量。首先将build目录下
的内容删除干净，然后</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre>cmake -G  "Unix Makefiles"  -DLLVM_USE_LINKER=gold   -DLLVM_ENABLE_PROJECTS="clang"  -DCMAKE_BUILD_TYPE=debug ../llvm
</pre></td></tr></tbody></table></code></pre></div></div>
<p>这样就生成了适合make构建的文件，然后使用</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre>make -j4
</pre></td></tr></tbody></table></code></pre></div></div>
<p>然后使用-j4限制了4线程编译，然后编译成功了。</p>

<p>以上部分主要参考这两个官方链接，一个是Getting Started with the LLVM System<a href="#refer-anchor-4"><sup>4</sup></a>，
一个是Getting Started: Building and Running Clang<a href="#refer-anchor-5"><sup>5</sup></a>，如果想进一步了解细节的，可以参考这两个链接。</p>

<h2 id="references">References</h2>

<div id="refer-anchor-1"></div>
<p>[1]. <a href="http://releases.llvm.org/download.html">llvm release版本下载</a></p>
<div id="refer-anchor-2"></div>
<p>[2]. <a href="https://github.com/llvm/llvm-project">llvm github 源码位置</a></p>
<div id="refer-anchor-3"></div>
<p>[3]. <a href="http://llvm.org/docs/CMake.html">llvm之cmake</a></p>
<div id="refer-anchor-4"></div>
<p>[4]. <a href="https://llvm.org/docs/GettingStarted.html">Getting Started with the LLVM System</a></p>
<div id="refer-anchor-5"></div>
<p>[5]. <a href="http://clang.llvm.org/get_started.html">Getting Started: Building and Running Clang</a></p>
:ET